#!/bin/sh

##set -x

#-----------------------------------------------------------------------------
# defs
#-----------------------------------------------------------------------------

prog=$(basename $0)

log_fn=jack.log

usage(){
    cat <<-EOF
$prog [-S | -k (jpP) | -r (jpP) ] [-w -d]

j = local and remote jackds in netjack2 mode
p = pulseaudio sink "jack_out"
P = pulseaudio service

options:
    -S       : show status
    -k (jpP) : kill stuff
    -r (jpP) : start or restart
    -w       : wifi mode (use more buffering, pay with increased AV delay)
    -d       : debug mode: write a logfile $log_fn on the local and remote
               machine

-rp: when we resume from suspend (to ram) mode, then the jackd connection
(netjack2) is still active and only the pulse sink needs a restart -> no need
to kill the jackds, which takes a bit longer.

examples:

    This is what you call when you need to start all
        $ $prog -rjp

    Check status
        $ $prog -S
        remote jackd    yes
        local jackd     yes
        jack_out sink   yes

    (Re)start all, including pulseaudio
        $ $prog -rjpP

    Disable pulse sink
        $ $prog -kp
        $ $prog -S
        remote jackd    yes
        local jackd     yes
        jack_out sink   NO

    Restart only pulse sink (e.g. after resuming from suspend mode)
        $ $prog -rp
EOF
}


cmd_stop_jack_remote=$(cat <<-EOF
    for sig in 15 9; do
        pkill -\$sig -f 'jackd.*-d'
        pkill -\$sig -f 'jackd.*-ndefault'
        pkill -\$sig jack_load
    done
EOF
)

err(){
    echo "error: $@"
    exit 1
}

yesno(){
    [ $1 -eq 0 ] && echo "yes" || echo "NO"
}

checkopt(){
    what=$1
    val=$2
    [ "$what" = "$none" ] && return 1
    echo "$what" | grep -q $val
    return $?
}

start_jack_local(){
    jackd $local_opts -P80 -d net $local_driver_opts >> $log 2>&1 &
    ps aux | grep jackd >> $log 2>&1
}


stop_jack_local(){
    for sig in 15 9; do
        pkill -$sig -f 'jackd.*-d'
        pkill -$sig -f 'jackd.*-ndefault'
    done
}

# The action of stop_jack_remote is performed in the ssh below so that we don't
# need to ssh twice, which would be slower.
restart_jack_remote(){
    eval "$ssh_cmd" <<-EOF
        export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/dbus/system_bus_socket
        (
        \$(date)
        echo "kill ..."
        $cmd_stop_jack_remote
        echo "start jackd ..."
        jackd $remote_opts -P80 -d alsa --device $remote_device \
           $remote_driver_opts &
        while ! pgrep -f 'jackd.*-P.*-d.*alsa.*--device'; do
            echo '\$(date) waiting for jackd ...'
            sleep 0.1
        done
        echo "load netmanager ..."
        jack_load netmanager -i -c
        ps aux | grep jackd
        ) > $log 2>&1
EOF
}

stop_jack_remote(){
    eval "$ssh_cmd" <<-EOF
        (
        $cmd_stop_jack_remote
        ) > $log 2>&1
EOF
}

stop_jack(){
    stop_jack_local
    stop_jack_remote
}

check_broken_pulse(){
    if ! pactl list sinks > /dev/null 2>&1; then
        err "pulseaudio broken, try '$prog -kP'"
    fi
}

stop_pulse(){
    systemctl --user stop pulseaudio.service pulseaudio.socket
}

restart_pulse(){
    systemctl --user restart pulseaudio.service
}

start_pulse_sink(){
    # This is only useful if local and remote jackds are already running in
    # netjack2 mode (-rj), else a local jackd with default args is started
    # (jackd -T -ndefault -T -d alsa), which is useless.
    check_broken_pulse
    if ! pactl list sinks | grep -q jack_out; then
        pactl load-module module-jack-sink >> $log 2>&1
        pactl set-sink-mute jack_out false
    fi
}

stop_pulse_sink(){
    check_broken_pulse
    if pactl list modules | grep -q module-jack-sink; then
        pactl unload-module module-jack-sink
    fi
}

restart_pulse_sink(){
    stop_pulse_sink
    sleep 0.5
    start_pulse_sink
}


do_check_status(){
    check_broken_pulse
    (
    eval "$ssh_cmd" <<-EOF
        yesno(){
            [ \$1 -eq 0 ] && echo "yes" || echo "NO"
        }
        pgrep -f 'jackd.*-P.*-d.*alsa.*--device' > /dev/null
        echo "remote jackd: \$(yesno \$?)"
EOF
    pgrep -f 'jackd.*-P.*-d.*net' > /dev/null
    echo "local jackd: $(yesno $?)"
    pactl list sinks | grep -q jack_out
    echo "jack_out sink: $(yesno $?)"
    ) | column -t -s:
}


#-----------------------------------------------------------------------------
# main
#-----------------------------------------------------------------------------

# The options here are meant to be changed for minimizing latency issues. The
# only preset we have is wifi_mode, which works more or less, but will need
# tuning for other networks. All other master and slave netjack2 related
# options are hard-coded in the functions above.
remote_opts="-R"
local_opts="-S -R"
remote_driver_opts="--nperiods 2 --period 512"
local_driver_opts="-l1"
wifi_mode=false

check_status=false
debug=false
# send stderr and stdout into the wild blue yonder, will be replaced with
# $log_fn when debug=true
log=/dev/null

# Hard-code the remote (master) hostname and our soundcard over there. If
# needed, add CLI flags for that or a config file, but .. really just hack
# these two lines.
remote=raspi
remote_device="hw:sndrpihifiberry"

# To avoid awkward gymnastics in checkopt ($# changes if any of the input args
# is an empty string), we define a None/null/nil value here that is not the
# empty string. Yes this tool should be written in another language.
none="::"
kill_what=$none
restart_what=$none

# B/c of quoting foo, use
#   eval $ssh_cmd [rest of ssh cmd line]
ssh_cmd="ssh -o ConnectTimeout=2 -T $remote"


while getopts k:wr:hSd opt; do
    case $opt in
        k) kill_what=$OPTARG;;
        w) wifi_mode=true;;
        r) restart_what=$OPTARG;;
        S) check_status=true;;
        d) debug=true;;
        h) usage; exit 0;;
        \?) exit 1;;
    esac
done
shift $((OPTIND - 1))

if $wifi_mode; then
    remote_driver_opts="--nperiods 2 --period 1024"
    local_driver_opts="-l1"
fi

if $debug; then
    log=$log_fn
    rm -f $log
fi

if $check_status; then
    do_check_status
    exit 0
fi

checkopt $kill_what p && stop_pulse_sink
checkopt $kill_what j && stop_jack
checkopt $kill_what P && stop_pulse

checkopt $restart_what P && restart_pulse

if checkopt $restart_what j; then
    check_broken_pulse
    stop_jack_local
    restart_jack_remote
    start_jack_local
fi

checkopt $restart_what p && restart_pulse_sink
